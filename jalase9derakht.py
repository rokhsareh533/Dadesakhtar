n! = (n-1)! # n
if n == 1
1
def fact(n) :
    if n == 1
    return1 
return fact(n-1) * n 



zarb(a,b) = zarb(a,b-1) + a 
if b == 1 
a 
def zarb(a,b) :
    if b == 1
    return a 
return zarb(a,b-1) + a 



tagh(a,b) = tagh(a-b,b) # 1 
if a < b 
0
def tagh (a,b) :
    if a < b :
        return 0 
    return tagh(a-b,b) + 1

if root is None
[]
def inorder (roat) :
    if root is None 
    return
    inorder(roat child) 
    print(root value)
    inorder(root.Rchild)
    T(n) = 2[(n/2)+1]
    n log 2 2 + 0(n)



def height(roat):
    if root is None :
        return 0
    return max (height(rchild)height(Rechild)) +1

def cout_leaves(roat) :
    if root == None :
        return 0
    if root Rechild == None and roat Rechild == None:
        return 1
    return cout_leaves(roat.lechid) +  cout_leves(roat_rchild)



def cout_Nodes_1 D(roat):
   if roat is None:
    return 0
   if roat Rchild is None and roat.Lchild is not None: 
      return1 + cout_nodes iD(roat.Lchild)
    if roat.Rchild is None and roat_Lchild is None :
    return 0
return 1 + cout_Nodes ID (roat.Rchild) + cout Nodes ID(roat Lchild)



if roat is None
+ binahayat
def max T2(roat):
   if roat is None 
    return floar(inf)
return max (max(roat lchild)maxT2(roat Rchild)roat)


def sum-T2(roat):
    if roat is None :
   return 0
return sum-T2(roat.lchild) =sum-T2(roat.Rchild)+cout.value 





    
